This design is based on LeapFrog Trie-Join\cite{DBLP:journals/corr/abs-1210-0481} and Fractal Tree Indices, as implemented by \textit{TokuDB}\cite{kuszmaul2009fractal}. We differentiate from each of these by:
\begin{itemize}
  \item Combining their disparate techniques.
  \item Adapting LeapFrog Trie-Join for use in the incremental setting.
  \item Further adapting it to count records without materialising them.
  \item Improving the amortized time complexity and number of IO's by taking advantage of the write-heavy access patterns to the materialised view.
  \item Providing expositions of the concrete data structures used to implement LeapFrog Trie-Join. This implementation is hinted at in the paper, but not explicitly given, as much of their paper deals with the algorithm written in terms of interfaces.
\end{itemize}

\subsection{Part (a)}\label{sec:q-1-a}
The algorithm relies heavily on the fact that tables do not contain duplicate values. Suppose we insert $t$ into $R_1$, then we have two cases.

Suppose $t\notin R_1$, then
\begin{itemize}
  \step[\imps] $(R_1\bowtie R_2)\cap(\{t\}\bowtie R_2) = \varnothing$
  \step[\imps] $\abs{(R_1\cup\{t\})\bowtie R_2} = \abs{R_1\bowtie R_2} + \abs{\{t\}\bowtie R_2}$
\end{itemize}

Suppose $t\in R_1$, then
\begin{itemize}
  \step[\imps] $\{t\}\bowtie R_2\subseteq R_1\bowtie R_2$
  \step[\imps] $\abs{(R_1\cup\{t\})\bowtie R_2} = \abs{R_1\bowtie R_2}$
\end{itemize}

Similarly, if we remove $t$ from $R_2$, we have two cases. Firstly, suppose $t\in R_1$, then
\begin{itemize}
  \step[\imps] $(R_1\setminus\{t\})\bowtie R_2 = (R_1\bowtie R_2)\setminus(\{t\}\bowtie R_2)$
  \marginnote{By the uniqueness of records in a table.}
  \step[\imps] $\abs{(R_1\setminus\{t\})\bowtie R_2} = \abs{R_1\bowtie R_2} - \abs{\{t\}\bowtie R_2}$
  \marginnote{$\{t\}\bowtie R_2\subseteq R_1\bowtie R_2$ as before.}
\end{itemize}

And when $t\notin R_1$, we have
\begin{itemize}
  \step[\imps] $(R_1\setminus\{t\})\bowtie R_2 = R_1\bowtie R_2$
  \step[\imps] $\abs{(R_1\setminus\{t\})\bowtie R_2} = \abs{R_1\bowtie R_2}$
\end{itemize}

From these results we see that (a) If the operation is redundant, then the query result does not need to be altered, and (b) If the operation is not redundant, we may compute a much smaller join (as in the hint) and use that to update the query result. In the case of \texttt{COUNT} queries, this means we do not need to materialise the join, but instead may keep a running total.

The pseudo-code that follows will be written in terms of the interfaces, given in Figures \ref{iface:table}, \ref{iface:iterator} and \ref{iface:view}.

\begin{marginfigure}
  \textbf{\texttt{T\,:\,table}}
  \begin{description}
    \item[\texttt{T.insert(r\,:\,record)\,:\,bool}]
      Insert \texttt{r} into \texttt{T}, if it does not already exist there. Returns \texttt{true} iff \texttt{T} changed as a result of the operation.
    \item[\texttt{T.delete(r\,:\,record)\,:\,bool}]
      Remove \texttt{r} from \texttt{T}, returning \texttt{true} iff \texttt{T} changed as a result of the operation.
    \item[\texttt{T.scan()\,:\,iterator}]
      Return an iterator by which we may scan through the records of \texttt{T}.
  \end{description}
  \caption{The interface for a table, which is used to store the input data.}\label{iface:table}
\end{marginfigure}

\begin{marginfigure}
  \textbf{\texttt{I\,:\,iterator}}
  \begin{description}
    \item[\texttt{I.key()\,:\,int}]
      Return the value of the record's key at the current position.
    \item[\texttt{I.get()\,:\,record}]
      Return the record at the current position.
    \item[\texttt{I.next()}]
      Move the iterator's cursor one step forward.
    \item[\texttt{I.seek(key\,:\,int)}]
      Move the iterator to the first record after its current position with a key greater than or equal to the one provided (or to the end if such a record does not exist).
    \item[\texttt{I.atEnd()\,:\,bool}]
      Returns \texttt{true} iff the iterator's cursor has passed the last record.
  \end{description}
  \caption{The interface for an iterator.}\label{iface:iterator}
\end{marginfigure}

\begin{marginfigure}
  \textbf{\texttt{V\,:\,view}}
  \begin{description}
    \item[\texttt{T.insert(r\,:\,record)}]
    \item[\texttt{T.delete(r\,:\,record)}]
  \end{description}
  \caption{Views have a similar interface to tables, but do not return a boolean after an update, allowing them to apply updates lazily. This class represents the materialised result of a join.}\label{iface:view}
\end{marginfigure}

\subsection{Part (a.i)}\label{sec:q-1-a-i}

W.l.o.g. suppose we have a sequence of updates $(u_i)_{i=1}^n$, all for $R_1$, we simply serve them sequentially (Algorithm~\ref{alg:up-loop}).

\begin{algorithm}
  \SetKwFunction{Update}{update}
  \For{$i\gets 1,\ldots,n$}{
    \Update{$u_i$}
  }
  \caption{Outer loop}\label{alg:up-loop}
\end{algorithm}

And then we serve each update as in Algorithms~\ref{alg:up-join-insert} and~\ref{alg:up-join-delete} in the case of Equijoin queries, and Algorithms~\ref{alg:up-count-insert} and~\ref{alg:up-count-delete} in the case of Count queries.

\begin{algorithm}
  \SetKwInOut{Input}{input}
  \SetKwFunction{RInsert}{$R_1$.insert}
  \SetKwFunction{VInsert}{$V$.insert}
  \SetKwFunction{Scan}{$R_2$.scan}
  \SetKwFunction{Seek}{$S_2$.seek}
  \SetKwFunction{Key}{$S_2$.key}
  \SetKwFunction{AtEnd}{$S_2$.atEnd}
  \SetKwFunction{Get}{$S_2$.get}
  \SetKwFunction{Next}{$S_2$.next}
  \SetKwFunction{Not}{not}

  \Input{$+R_1(a, b)$}
  \Begin{
      \If{\Not\RInsert{a, b}}{
        \KwRet\;
      }
      $S_2\gets $\Scan{}\;
      \Seek{a}\;
      \While{$\Key{} = a\wedge\Not~\AtEnd{}$}{
        $(a^\prime,c)\gets $\Get{}\;
        \VInsert{a, b, c}\;
        \Next{}\;
      }
    }
  \caption{Updating an Equijoin query after an insertion, assuming \texttt{V\,:\,view} holds the current result.}\label{alg:up-join-insert}
\end{algorithm}
\begin{algorithm}
  \SetKwInOut{Input}{input}
  \SetKwFunction{RDelete}{$R_1$.delete}
  \SetKwFunction{VDelete}{$V$.delete}
  \SetKwFunction{Scan}{$R_2$.scan}
  \SetKwFunction{Seek}{$S_2$.seek}
  \SetKwFunction{Key}{$S_2$.key}
  \SetKwFunction{AtEnd}{$S_2$.atEnd}
  \SetKwFunction{Get}{$S_2$.get}
  \SetKwFunction{Next}{$S_2$.next}
  \SetKwFunction{Not}{not}
  \Input{$-R_1(a, b)$}
  \Begin{
      \If{\Not\RDelete{a, b}}{
        \KwRet\;
      }
      $S_2\gets $\Scan{}\;
      \Seek{a}\;
      \While{$\Key{} = a\wedge\Not~\AtEnd{}$}{
        $(a^\prime,c)\gets $\Get{}\;
        \VDelete{a, b, c}\;
        \Next{}\;
      }
    }
  \caption{Updating an Equijoin query after a deletion, assuming \texttt{V\,:\,view} holds the current result.}\label{alg:up-join-delete}
\end{algorithm}

\begin{algorithm}
  \SetKwInOut{Input}{input}
  \SetKwFunction{RInsert}{$R_1$.insert}
  \SetKwFunction{Scan}{$R_2$.scan}
  \SetKwFunction{Seek}{$S_2$.seek}
  \SetKwFunction{Key}{$S_2$.key}
  \SetKwFunction{AtEnd}{$S_2$.atEnd}
  \SetKwFunction{Get}{$S_2$.get}
  \SetKwFunction{Next}{$S_2$.next}
  \SetKwFunction{Not}{not}

  \Input{$+R_1(a, b)$}
  \Begin{
      \If{\Not\RInsert{a, b}}{
        \KwRet\;
      }
      $S_2\gets $\Scan{}\;
      \Seek{a}\;
      \While{$\Key{} = a\wedge\Not~\AtEnd{}$}{
        $C\gets C + 1$\;
        \Next{}\;
      }
    }
  \caption{Updating a Count query after an insertion, assuming \texttt{C\,:\,int} holds the current result.}\label{alg:up-count-insert}
\end{algorithm}
\begin{algorithm}
  \SetKwInOut{Input}{input}
  \SetKwFunction{RDelete}{$R_1$.delete}
  \SetKwFunction{Scan}{$R_2$.scan}
  \SetKwFunction{Seek}{$S_2$.seek}
  \SetKwFunction{Key}{$S_2$.key}
  \SetKwFunction{AtEnd}{$S_2$.atEnd}
  \SetKwFunction{Get}{$S_2$.get}
  \SetKwFunction{Next}{$S_2$.next}
  \SetKwFunction{Not}{not}
  \Input{$-R_1(a, b)$}
  \Begin{
      \If{\Not\RDelete{a, b}}{
        \KwRet\;
      }
      $S_2\gets $\Scan{}\;
      \Seek{a}\;
      \While{$\Key{} = a\wedge\Not~\AtEnd{}$}{
        $C\gets C - 1$\;
        \Next{}\;
      }
    }
  \caption{Updating a Count query after a deletion, assuming \texttt{C\,:\,int} holds the current result.}\label{alg:up-count-delete}
\end{algorithm}

\subsection{Part (a.iv)}\label{sec:q-1-a-iv}

Next we focus on the data structures we will use to implement the algorithm, as precisely what they are will affect the example runs and the performance analysis.\\[1em]

Our input tables will be stored in clustered B+-trees keyed on $A$, to make the requisite range queries as fast as possible.\\[1em]

The materialised view will be stored in a Fractal Tree Index, again keyed on $A$. Fractal Tree Indices are write-optimized data structures similar to the B+-tree, but at each internal node, some space is reserved for a list of pending transactions, which is shared equally amongst the node's children. When an update is made to the structure, if the root node is a leaf, it is applied immediately, but if not, it is added to the transaction buffer corresponding to the child node it would have been sent to.\\[1em]

If a transaction buffer becomes full, its contents will be flushed to its corresponding child. Flushes may cascade all the way down to leaf nodes.\\[1em]

At most one transaction can be held in a buffer for any one record, $r$. If two transactions $t_1$, followed by $t_2$ are put into the same buffer, both pertaining to $r$, we always keep the later one (in this case, $t_2$).\\[1em]

To ensure reads stay consistent with writes, when making point queries, we must check the transaction buffers of nodes we go through, and similarly, when making range queries, we must first flush all transaction buffers corresponding to ancestor nodes of leaves we may touch.\\[1em]

Using a Fractal Tree Index improves the amortized cost of serving a sequence of updates to the materialised view, even if the worst-case cost of an individual update is not improved upon. This is ideal in our case as we are trying to make maintaining the materialised view (an exclusively write heavy operation) as cheap as possible. The trade-off is that reading the database is less efficient, by a constant factor, because the fan-out of the tree structure is reduced, and we must check transaction buffers as well as leaves.

\subsection{Part (a.ii)}\label{sec:q-1-a-ii}

In the worked examples to follow, rectangular nodes represent the intermediate and leaf nodes of the tree, whilst nodes with rounded corners represent transaction buffers, and are part of their parent nodes. To differentiate between B+-trees and Fractal Trees, the former use solid edges, whilst the latter use dashed edges, labeled by the corresponding transaction buffer.\\[1em]

In leaf nodes $\times$ is used to denote an empty slot, whilst empty slots are omitted from branch nodes, and $\varnothing$ is used to denote an empty transaction buffer. Whenever an entry in a nodes appears to break an invariant of the data structure, it will be formatted \textbf{\textcolor{red}{red and in bold}}.\\[1em]

For the purposes of these examples, we will say that all leaf nodes may hold 4 records, the branch nodes of B+-trees will have a fan-out of 5 (4 pivot keys), and the branch nodes of Fractal Trees will have a fan-out of 3 (2 pivot keys), and a transaction buffer fitting one transaction per child.

\begin{align*}
  \text{Suppose}\quad R_1 & = \{(2i,1):1\leq i\leq 8\}
  \\                  R_2 & = \{(4i,2), (4i,3) : 1\leq i\leq 4\}
\end{align*}

\vspace{2mm}

\begin{center}
  \marginnote{First we load data into the B+-tree for $R_1$.}
  \begin{tikzpicture}
    \tikzstyle{bplus}=[rectangle split, rectangle split horizontal,rectangle split ignore empty parts,draw, fill=white]
    \tikzstyle{every node}=[bplus]
    \tikzstyle{level 1}=[sibling distance=40mm]

    \node {$8$} [->]
    child {node {$2,1$ \nodepart{two} $4,1$ \nodepart{three} $6,1$ \nodepart{four} $8,1$}}
    child {node {$10,1$ \nodepart{two} $12,1$ \nodepart{three} $14,1$ \nodepart{four} $16,1$}}
    ;\end{tikzpicture}
\end{center}

\vspace{5mm}

\begin{center}
  \marginnote{And the B+-tree for $R_2$.}
  \begin{tikzpicture}
    \tikzstyle{bplus}=[rectangle split, rectangle split horizontal,rectangle split ignore empty parts,draw, fill=white]
    \tikzstyle{every node}=[bplus]
    \tikzstyle{level 1}=[sibling distance=40mm]

    \node {$8$} [->]
    child {node {$4,2$ \nodepart{two} $4,3$ \nodepart{three} $8,2$ \nodepart{four} $8,3$}}
    child {node {$12,2$ \nodepart{two} $12,3$ \nodepart{three} $16,2$ \nodepart{four} $16,3$}}
    ;\end{tikzpicture}
\end{center}

\vspace{5mm}

\marginnote{We build the initial view using LeapFrog Trie-Join, which gives us the records $(4,1,2)$, $(4,1,3)$, $(8,1,2)$, $(8,1,3)$, $(12,1,2)$, $(12,1,3)$, $(16,1,2)$, $(16,1,3)$ to insert into the Fractal Tree.}
\begin{center}
  \begin{tikzpicture}
    \tikzstyle{bplus}=[rectangle split, rectangle split horizontal,rectangle split ignore empty parts,draw, fill=white]
    \tikzstyle{every node}=[bplus]
    \tikzstyle{level 1}=[sibling distance=50mm]

    \node {$8$} [->]
    child {node {$4,1,2$ \nodepart{two} $4,1,3$ \nodepart{three} $8,1,2$ \nodepart{four} $\times$} edge from parent[dashed] node[solid,rectangle,rounded corners=7pt,fill=white,draw] {$\varnothing$}}
    child {node {$8,1,3$ \nodepart{two} $12,1,2$ \nodepart{three} $12,1,3$ \nodepart{four} $16,1,2$} edge from parent[dashed] node[solid,rectangle,rounded corners=7pt,fill=white,draw] {$+(16,1,3)$}}
    ;\end{tikzpicture}
\end{center}

\vspace{5mm}

\marginnote{Now suppose we perform $+R_1(4,2)$, updating $R_1$'s B+-tree.}
\begin{center}
  \begin{tikzpicture}
    \tikzstyle{bplus}=[rectangle split, rectangle split horizontal,rectangle split ignore empty parts,draw, fill=white]
    \tikzstyle{every node}=[bplus]
    \tikzstyle{level 1}=[sibling distance=35mm]

    \node {$4$\nodepart{two}$8$} [->]
    child {node {$2,1$ \nodepart{two} $4,1$ \nodepart{three} $4,2$ \nodepart{four} $\times$}}
    child {node {$6,1$ \nodepart{two} $8,1$ \nodepart{three} $\times$ \nodepart{four} $\times$}}
    child {node {$10,1$ \nodepart{two} $12,1$ \nodepart{three} $14,1$ \nodepart{four} $16,1$}}
    ;\end{tikzpicture}
\end{center}

\marginnote{We seek for $4$ in $R_2$, finding $(4,2)$,$(4,3)$, and causing us to insert $(4,2,2)$,$(4,2,3)$ into the view.}
\begin{center}
  \begin{tikzpicture}
    \tikzstyle{bplus}=[rectangle split, rectangle split horizontal,rectangle split ignore empty parts,draw,fill=white]
    \tikzstyle{every node}=[bplus]
    \tikzstyle{level 1}=[sibling distance=60mm]

    \node {$8$} [->]
    child {node {$4,1,2$ \nodepart{two} $4,1,3$ \nodepart{three} $8,1,2$ \nodepart{four} $\times$} edge from parent[dashed] node[solid,rectangle split parts=2,rectangle split horizontal, rectangle split ignore empty parts,rounded corners=7pt] {$+(4,2,2)$\nodepart{two}\textcolor{red}{$\mathbf{+(4,2,3)}$}}}
    child {node {$8,1,3$ \nodepart{two} $12,1,2$ \nodepart{three} $12,1,3$ \nodepart{four} $16,1,2$} edge from parent[dashed] node[solid,rectangle,rounded corners=7pt,fill=white,draw] {$+(16,1,3)$}}
    ;\end{tikzpicture}
\end{center}

\vspace{5mm}

\marginnote{We flush the overfull transaction buffer.}
\begin{center}
  \begin{tikzpicture}
    \tikzstyle{bplus}=[rectangle split, rectangle split horizontal,rectangle split ignore empty parts,draw,fill=white]
    \tikzstyle{every node}=[bplus]
    \tikzstyle{level 1}=[sibling distance=60mm]

    \node {$8$} [->]
    child {node[rectangle split parts=5] {$4,1,2$ \nodepart{two} $4,1,3$ \nodepart{three} $4,2,2$ \nodepart{four} $4,2,3$ \nodepart{five} \textcolor{red}{$\mathbf{8,1,2}$}} edge from parent[dashed] node[solid,rectangle, rounded corners=7pt,fill=white,draw] {$\varnothing$}}
    child {node[] {$8,1,3$ \nodepart{two} $12,1,2$ \nodepart{three} $12,1,3$ \nodepart{four} $16,1,2$} edge from parent[dashed] node[solid,rectangle, rounded corners=7pt,fill=white,draw] {$+(16,1,3)$}}
    ;\end{tikzpicture}
\end{center}

\vspace{5mm}

\marginnote{Flushing the transaction buffer caused the leaf node to overfill, so we split that too.}
\begin{center}
  \begin{tikzpicture}
    \tikzstyle{bplus}=[rectangle split, rectangle split horizontal,rectangle split ignore empty parts,draw,fill=white]
    \tikzstyle{every node}=[bplus]
    \tikzstyle{level 1}=[sibling distance=45mm]

    \node {$4$\nodepart{two}$8$} [->]
    child {node {$4,1,2$ \nodepart{two} $4,1,3$ \nodepart{three} $4,2,2$ \nodepart{four} $\times$} edge from parent[dashed] node[solid,rectangle,rounded corners=7pt,fill=white,draw] {$\varnothing$}}
    child {node {$4,2,3$ \nodepart{two} $8,1,2$ \nodepart{three} $\times$ \nodepart{four} $\times$} edge from parent[dashed] node[solid,rectangle,rounded corners=7pt,fill=white,draw] {$\varnothing$}}
    child {node[] {$8,1,3$ \nodepart{two} $12,1,2$ \nodepart{three} $12,1,3$ \nodepart{four} $16,1,2$} edge from parent[dashed] node[solid,rectangle,rounded corners=7pt,fill=white,draw] {$+(16,1,3)$}}
    ;\end{tikzpicture}
\end{center}

\vspace{5mm}

\marginnote{Then suppose we perform $-R_1(16, 1)$}
\begin{center}
  \begin{tikzpicture}
    \tikzstyle{bplus}=[rectangle split, rectangle split horizontal,rectangle split ignore empty parts,draw, fill=white]
    \tikzstyle{every node}=[bplus]
    \tikzstyle{level 1}=[sibling distance=35mm]

    \node {$4$\nodepart{two}$8$} [->]
    child {node {$2,1$ \nodepart{two} $4,1$ \nodepart{three} $4,2$ \nodepart{four} $\times$}}
    child {node {$6,1$ \nodepart{two} $8,1$ \nodepart{three} $\times$ \nodepart{four} $\times$}}
    child {node {$10,1$ \nodepart{two} $12,1$ \nodepart{three} $14,1$ \nodepart{four} $\times$}}
    ;\end{tikzpicture}
\end{center}

\vspace{5mm}

\marginnote{Seeking for $16$ in $R_2$, we find $(16, 2)$, $(16, 3)$, causing us to delete $(16, 1, 2)$ and $(16, 1, 3)$.}
\begin{center}
  \begin{tikzpicture}
    \tikzstyle{bplus}=[rectangle split, rectangle split horizontal,rectangle split ignore empty parts,draw,fill=white]
    \tikzstyle{every node}=[bplus]
    \tikzstyle{level 1}=[sibling distance=50mm]

    \node {$4$\nodepart{two}$8$} [->]
    child {node {$4,1,2$ \nodepart{two} $4,1,3$ \nodepart{three} $4,2,2$ \nodepart{four} $\times$} edge from parent[dashed] node[solid,rectangle,rounded corners=7pt,fill=white,draw] {$\varnothing$}}
    child {node {$4,2,3$ \nodepart{two} $8,1,2$ \nodepart{three} $\times$ \nodepart{four} $\times$} edge from parent[dashed] node[solid,rectangle,rounded corners=7pt,fill=white,draw] {$\varnothing$}}
    child {node {$8,1,3$ \nodepart{two} $12,1,2$ \nodepart{three} $12,1,3$ \nodepart{four} $16,1,2$} edge from parent[dashed] node[solid,rectangle split parts=2,rectangle split horizontal, rectangle split ignore empty parts,rounded corners=7pt] {$-(16,1,2)$\nodepart{two}\textcolor{red}{$\mathbf{-(16,1,3)}$}}}
    ;\end{tikzpicture}
\end{center}

\marginnote{The overfull transaction buffer is flushed.}
\begin{center}
  \begin{tikzpicture}
    \tikzstyle{bplus}=[rectangle split, rectangle split horizontal,rectangle split ignore empty parts,draw,fill=white]
    \tikzstyle{every node}=[bplus]
    \tikzstyle{level 1}=[sibling distance=40mm]

    \node {$4$\nodepart{two}$8$} [->]
    child {node {$4,1,2$ \nodepart{two} $4,1,3$ \nodepart{three} $4,2,2$ \nodepart{four} $\times$} edge from parent[dashed] node[solid,rectangle,rounded corners=7pt,fill=white,draw] {$\varnothing$}}
    child {node {$4,2,3$ \nodepart{two} $8,1,2$ \nodepart{three} $\times$ \nodepart{four} $\times$} edge from parent[dashed] node[solid,rectangle,rounded corners=7pt,fill=white,draw] {$\varnothing$}}
    child {node {$8,1,3$ \nodepart{two} $12,1,2$ \nodepart{three} $12,1,3$ \nodepart{four} $\times$} edge from parent[dashed] node[solid,rectangle,rounded corners=7pt,fill=white,draw] {$\varnothing$}}
    ;\end{tikzpicture}
\end{center}

If instead we are preserving a count query, given the same updates:

\begin{align*}
  &            && \phantom{+2~}\text{ Initially } & C & = 8 \\
  & +R_1(4,2)  && +2\text{ records }\implies      & C & = 10 \\
  & -R_1(16,1) && -2\text{ records }\implies      & C & = 8
\end{align*}

\subsection{Part (a.iii)}\label{sec:q-1-a-iii}
We will use the IO Model to measure performance, counting the number of page reads and writes required for each operation, in the worst-case.

\begin{flalign*}
  \text{Let}\quad m & = \text{ Number of updates to deal with.} &&\\
  P_1 & = \text{ Number of pages in }R_1 &&\\
  P_2 & = \text{ Number of pages in }R_2 &&\\
  P_V & = \text{ Number of pages in the materialised view.} &&\\
  T & = \text{ The total number of records added/removed from the view.} &&\\
  B & = \text{ Branch factor of the B+-tree.} &&\\
  \sqrt{B} & = \text{ Branch factor of the Fractal Tree.} &&\\
  B - \sqrt{B} & = \text{ Total size of the transaction buffer (shared amongst children).} &&\\
  \frac{B - \sqrt{B}}{\sqrt{B}} & = \text{ Size of transaction buffer allocated per child.} &&
\end{flalign*}
\noindent W.l.o.g. let $P_1\leq P_2$.\\[1em]

Joining $R_1$ and $R_2$ using LeapFrog Trie-Join (assuming they are already sorted) will, in the worst-case cost:
\begin{itemize}
  \item $P_1 + P_2$ IO's to merge.
  \item $P_V$ IO's to materialize.
\end{itemize}
So, the na\"ive implementation will take $O(m(P_1 + P_2 + P_V))$ IO's to maintain an equijoin query, and $O(m(P1 + P2))$ IO's to maintain a count query, in the worst-case.\\[1em]

An incremental approach incurs the following costs:
\begin{itemize}
  \item For each update to one table, we will scan the other table to find corresponding records. In the worst case this would take $P_2$ IO's.
  \item For each of the corresponding records, we issue a transaction. To minimise the number of times we write the root node of the view back, we pin it.
  \item Whenever we flush a transaction buffer, it is because we have more than $\frac{B - \sqrt{B}}{\sqrt{B}}=O(\sqrt{B})$ transactions waiting --- this follows because we only flush when the transaction buffer is full. A single flush costs $1$ IO, so the amortized cost per transaction is $O(\frac{1}{\sqrt{B}})$.
  \item Each transaction we add will be flushed at most $2\log_B(P_V)$ times.
  \item $mP_2$ IO's are spent scanning.
  \item $\frac{2T\log_B(P_V)}{\sqrt{B}}$ IO's are spent flushing transactions.
\end{itemize}

So we have that an equijoin query can be maintained with ${O(mP_2 + \frac{T\log_B(P_V)}{\sqrt{B}})}$ IO's and a count query with $O(mP_2)$ IO's. It is also worth noting that in the case of the former, we assumed in our analysis that all the transactions would be flushed all the way to the leaves during the course of maintaining the view, whereas this is not necessarily the case.\\[1em]

In both the na\"ive and incremental setting, these figures remain unchanged if instead of $m$ individual updates, we are dealing with $m$ bulk updates.\\[1em]

In the case of the count query, the improvement is obvious: We avoid the cost of scanning a whole table, for every update. With equijoins, it is not always clear that we will see an improvement. In pathological cases, each update may change the query result wildly. This would result in the index having to process a great many transactions, and in that case, it may be more efficient to recompute the result from scratch. However, in typical cases where each update does not change the overall result a great deal ($T$ is small), we can see clear improvements.

\subsection{Part (b/c)}\label{sec:q-1-b}

Now suppose we have $k$ tables, $R_1,\ldots,R_k$ that we wish to join together. We generalise the algorithm from part (a), implementing a fully-fledged Trie-Join between the updated record and every other table.\\[1em]

Firstly, we require that there is a global ordering of variables --- of which there are $v$ --- mentioned in the query. For instance, in the case of $R_1(A,B)\bowtie R_2(A,C)\bowtie R_3(B,C)$, we may choose $A\prec B\prec C$. We may then represent tables by tries whose ordering is determined as a subsequence of this global ordering.\\[1em]

\begin{marginfigure}
  \textbf{\texttt{I\,:\,iterator}}
  \begin{description}
    \item[\texttt{I.open()}]
      Move the iterator's cursor one level deeper, positioning the cursor at the first available key there.
    \item[\texttt{I.up()}]
      Move the iterator's cursor back up one level, positioning the cursor at the parent key at this depth.
    \item[\texttt{I.atValidDepth()\,:\,bool}]
      Returns \texttt{true} iff the table represented by this iterator should participte in the join over the query variable corresponding to the iterator's current depth.
  \end{description}
  \caption{Additions to the iterator interface, making it a trie iterator.}\label{iface:trie-iterator}
\end{marginfigure}

Secondly, we augment the iterator interface (Figure~\ref{iface:trie-iterator}), to descend and ascend levels in the trie representation of tables\cite{DBLP:journals/corr/abs-1210-0481}. If a trie has no values at a given level (the table it is representing is not participating in the join over this query variable) then the trie will return $-\infty$ for the key.\\[1em]

With the introduction of this trie representation, \texttt{I.get()} becomes redundant: Consumers of iterators may keep track of the current prefix of the record they are traversing as they move up and down the trie by making calls to \texttt{I.key()}. We provide a higher order function --- \texttt{traverse} --- to capture this notion (Algorithm~\ref{alg:traverse}).\\[1em]

\begin{algorithm}
  \SetKwInOut{Input}{input}
  \SetKwFunction{Not}{not}
  \SetKwFunction{Open}{open}
  \SetKwFunction{Up}{up}
  \SetKwFunction{Next}{next}
  \SetKwFunction{Key}{key}
  \SetKwFunction{AtEnd}{atEnd}
  \SetKwFunction{Traverse}{traverse}
  \Input{$\mathit{it}$, The iterator to scan through.}
  \Input{$\mathit{rec}$, A buffer in which to store the current record}
  \Input{$\mathit{act}$, A function to call for each new record.}
  \Input{$\mathit{pos}$, The current level of the iterator.}
  \Input{$\mathit{depth}$, The maximum level of the iterator.}
  \Begin{
      \If{$\mathit{pos}\geq\mathit{depth}$}{
        $\mathit{act}()$\;
        \KwRet\;
      }

      $\mathit{it}$.\Open{}\;
      \While{\Not$\mathit{it}$.\AtEnd{}} {
        $\mathit{rec}[\mathit{pos}]\gets \mathit{it}.\Key{}$\;
        \Traverse{$\mathit{it}$, $\mathit{depth}$, $\mathit{rec}$, $\mathit{act}$, $\mathit{pos} + 1$}\;
        $\mathit{it}$.\Next{}\;
      }
      $\mathit{it}$.\Up{}\;
  }

  \caption{The \texttt{traverse} function, for scanning through the records in a
    trie iterator.}\label{alg:traverse}
\end{algorithm}

Finally, we add a function \texttt{singleton(i, x, j, y\,:\,int)\,:\,iterator}, returning an iterator to a ``table'' containing only the record \texttt{(x, y)} with its first column at position \texttt{i} and its second column at position \texttt{j} in the global ordering (Algorithm~\ref{alg:singleton-it}). This is used to represent the relation containing the updated record, through a trie iterator interface, so that the Trie-Join algorithm may consume it as input.\\[1em]

\begin{algorithm}
  \SetKwProg{Fn}{func}{}{}
  \SetKwInOut{Input}{input}
  \SetKwInOut{Output}{output}
  \SetKwFunction{Open}{open}
  \SetKwFunction{Up}{up}
  \SetKwFunction{Next}{next}
  \SetKwFunction{Seek}{seek}
  \SetKwFunction{Key}{key}
  \SetKwFunction{AtEnd}{atEnd}

  \Input{$i, x, j, y$, where $i, j$ are the positions in the ordering of the first and second columns respectively, and $x, y$ are the values of the first and second columns respectively.}
  \Output{$it$, an iterator}
  \Begin{
      $\mathit{depth}\gets -1$\;
      $\mathit{done}_i\gets\texttt{false}$\;
      $\mathit{done}_j\gets\texttt{false}$\;
      $it\gets\varnothing$\;
      \Fn{$it$.\Open{}}{
        $\mathit{depth}\gets\mathit{depth} + 1$\;
      }
      \BlankLine
      \Fn{$it$.\Up{}}{
        $\mathit{depth}\gets\mathit{depth} - 1$\;
        $\mathit{done_i}\gets\mathit{done_i}\wedge\mathit{depth}\geq i$\;
        $\mathit{done_j}\gets\mathit{done_j}\wedge\mathit{depth}\geq j$\;
      }
      \BlankLine
      \Fn{$it$.\Next{}}{
        $\mathit{done_i}\gets\mathit{done_i}~\vee~\mathit{depth}=i$\;
        $\mathit{done_j}\gets\mathit{done_j}~\vee~\mathit{depth}=j$\;
      }
      \BlankLine
      \Fn{$it$.\Seek{key}}{
        $\mathit{done_i}\gets\mathit{done_i}~\vee~\mathit{depth}=i\wedge\mathit{key} > x$\;
        $\mathit{done_j}\gets\mathit{done_j}~\vee~\mathit{depth}=j\wedge\mathit{key} > y$\;
      }
      \BlankLine
      \Fn{$it$.\Key{}}{
        \uIf{$it$.\AtEnd{}}{
          \KwRet{$\infty$};
        }
        \uElseIf{$\mathit{depth} = i$} {
          \KwRet{$x$}\;
        }
        \uElseIf{$\mathit{depth} = j$} {
          \KwRet{$y$}\;
        }
        \Else{
          \KwRet{$-\infty$}\;
        }
      }
      \BlankLine
      \Fn{$it$.\AtEnd{}}{
        \KwRet{$\mathit{depth} = i\wedge\mathit{done}_i~\vee~\mathit{depth} = j\wedge\mathit{done}_j$}\;
      }
      \BlankLine
      \KwRet{$it$}\;
    }
  \caption{Function to produce a singleton relation $\{(x, y)\}$ exposed through the \texttt{iterator} interface.}\label{alg:singleton-it}
\end{algorithm}

Once again, W.l.o.g. we assume that all our updates are for $R_1$, and furthermore, $R_1$'s columns appear at positions $p_1$ and $p_2$ respectively, in the global ordering. Our outer loop remains unchanged (Algorithm~\ref{alg:up-loop}), but we rephrase our update routines in terms of an implementation of the Trie-Join algorithm \cite{DBLP:journals/corr/abs-1210-0481}. We omit the algorithm here as it is available at the cited paper, but assume it is available as \texttt{trie-join(its\,:\,[iterator])\,:\,iterator}. Algorithms~\ref{alg:up-trie-join-insert} and~\ref{alg:up-trie-join-delete} give the new update routines for equijoin queries, and Algorithms~\ref{alg:up-trie-count-insert} and~\ref{alg:up-trie-count-delete} are the new update routines for count queries.\\[1em]

\begin{algorithm}
  \SetKwProg{Fn}{func}{}{}
  \SetKwInOut{Input}{input}
  \SetKwFunction{RInsert}{$R_1$.insert}
  \SetKwFunction{TrieJoin}{trie-join}
  \SetKwFunction{Singleton}{singleton}
  \SetKwFunction{Act}{act}
  \SetKwFunction{Int}{int}
  \SetKwFunction{Traverse}{traverse}
  \SetKwFunction{VInsert}{$V$.insert}
  \SetKwFunction{Scan}{scan}

  \Input{$+R_1(a, b)$}
  \Begin{
      \If{\Not\RInsert{a, b}}{
        \KwRet\;
      }
      $\mathit{its}\gets[\Singleton{$p_1$,\,a,\,$p_2$,\,b},R_2.\Scan{},\ldots,R_k.\Scan{}]$\;
      $J\gets\TrieJoin{$\mathit{its}$}$\;
      $r\gets\KwSty{new}~\Int{v}$\;
      \Fn{\Act{}} {
        \VInsert{$r$}\;
      }
      \Traverse{$J$, $v$, $r$, \Act, $0$}\;
    }
  \caption{Updating an Equijoin query after an insertion, assuming \texttt{V\,:\,view} holds the current result, and $v$ is the number of variables in the query.}\label{alg:up-trie-join-insert}
\end{algorithm}
\begin{algorithm}
  \SetKwProg{Fn}{func}{}{}
  \SetKwInOut{Input}{input}
  \SetKwFunction{RDelete}{$R_1$.delete}
  \SetKwFunction{TrieJoin}{trie-join}
  \SetKwFunction{Singleton}{singleton}
  \SetKwFunction{Act}{act}
  \SetKwFunction{Int}{int}
  \SetKwFunction{Traverse}{traverse}
  \SetKwFunction{VDelete}{$V$.delete}
  \SetKwFunction{Scan}{scan}
  \Input{$-R_1(a, b)$}
  \Begin{
      \If{\Not\RDelete{a, b}}{
        \KwRet\;
      }
      $\mathit{its}\gets[\Singleton{$p_1$,\,a,\,$p_2$,\,b},R_2.\Scan{},\ldots,R_k.\Scan{}]$\;
      $J\gets\TrieJoin{$\mathit{its}$}$\;
      $r\gets\KwSty{new}~\Int{v}$\;
      \Fn{\Act{}} {
        \VDelete{$r$}\;
      }
      \Traverse{$J$, $v$, $r$, \Act, $0$}\;
    }
  \caption{Updating an Equijoin query after a deletion, assuming \texttt{V\,:\,view} holds the current result, and $v$ is the number of variables in the query.}\label{alg:up-trie-join-delete}
\end{algorithm}

\begin{algorithm}
  \SetKwProg{Fn}{func}{}{}
  \SetKwInOut{Input}{input}
  \SetKwFunction{RInsert}{$R_1$.insert}
  \SetKwFunction{TrieJoin}{trie-join}
  \SetKwFunction{Singleton}{singleton}
  \SetKwFunction{Act}{act}
  \SetKwFunction{Int}{int}
  \SetKwFunction{Traverse}{traverse}
  \SetKwFunction{Scan}{scan}

  \Input{$+R_1(a, b)$}
  \Begin{
      \If{\Not\RInsert{a, b}}{
        \KwRet\;
      }
      $\mathit{its}\gets[\Singleton{$p_1$,\,a,\,$p_2$,\,b},R_2.\Scan{},\ldots,R_k.\Scan{}]$\;
      $J\gets\TrieJoin{$\mathit{its}$}$\;
      $r\gets\KwSty{new}~\Int{v}$\;
      \Fn{\Act{}} {
        $C\gets C + 1$\;
      }
      \Traverse{$J$, $v$, $r$, \Act, $0$}\;
    }
  \caption{Updating a Count query after an insertion, assuming \texttt{C\,:\,int} holds the current result, and $v$ is the number of variables in the query.}\label{alg:up-trie-count-insert}
\end{algorithm}
\begin{algorithm}
  \SetKwProg{Fn}{func}{}{}
  \SetKwInOut{Input}{input}
  \SetKwFunction{RDelete}{$R_1$.delete}
  \SetKwFunction{TrieJoin}{trie-join}
  \SetKwFunction{Singleton}{singleton}
  \SetKwFunction{Act}{act}
  \SetKwFunction{Int}{int}
  \SetKwFunction{Traverse}{traverse}
  \SetKwFunction{Scan}{scan}

  \Input{$-R_1(a, b)$}
  \Begin{
      \If{\Not\RInsert{a, b}}{
        \KwRet\;
      }
      $\mathit{its}\gets[\Singleton{$p_1$,\,a,\,$p_2$,\,b},R_2.\Scan{},\ldots,R_k.\Scan{}]$\;
      $J\gets\TrieJoin{$\mathit{its}$}$\;
      $r\gets\KwSty{new}~\Int{v}$\;
      \Fn{\Act{}} {
        $C\gets C - 1$\;
      }
      \Traverse{$J$, $v$, $r$, \Act, $0$}\;
    }
  \caption{Updating a Count query after a deletion, assuming \texttt{C\,:\,int} holds the current result, and $v$ is the number of variables in the query.}\label{alg:up-trie-count-delete}
\end{algorithm}

The materialised view data structure remains mostly unchanged, although now, the index is keyed on \textit{all} columns in the result, with the order being given by the global ordering, this is done in the usual way, whereby at each intermediate node, partitioning ``keys'' are in fact entire partitioning \textit{records}.\\[1em]

We transform the representation of input tables in a similar manner, so that they are stored in indices keyed on all of their columns. However, we choose a different tactic to the one we employed for the view here: We nest indices. Let $R(a, b)$ be an input table with its columns having positions in the global ordering $p_a\prec p_b$ respectively, then the index representing $R$ begins (at the root) as an index keyed on $a$, at whose leaves are indices keyed on $b$. We do this because it mirrors the trie representation that we must expose through the \texttt{iterator} interface, and in doing so improves the performance of trie operations. The down-side is that as we nest indices deeper and deeper, we may waste space. For example, in the worst-case, suppose $a$ is a primary key for the relation, then we will end up allocating an entire page (the leaf node for the $b$-keyed index) for each record. As we are nesting only one layer deep, however, this sparsity in the leaves will be manageable.\\[1em]

For the worked example, we use the same notation as in Part (a.ii), although the data structures have changed and now we are maintaining a view of the triangle join: $R_1(A,B)\bowtie R_2(A,C)\bowtie R_3(B,C)$:
\begin{align*}
  \text{Let}\quad R_1 & = \{(2i,1):1\leq i\leq 8\}
  \\              R_2 & = \{(4i,2), (4i,3) : 1\leq i\leq 4\}
  \\              R_3 & = \{(1,2)\}
\end{align*}

\vspace{2mm}

\begin{center}
  \scalebox{.7}{
  \begin{tikzpicture}
    \tikzstyle{bplus}=[rectangle split, rectangle split horizontal,rectangle split ignore empty parts,draw, fill=white]
    \tikzstyle{every node}=[bplus]
    \tikzstyle{level 1}=[sibling distance=90mm]
    \tikzstyle{level 2}=[sibling distance=22mm]

    \node {$8$} [->]
    child {node {$2$ \nodepart{two} $4$ \nodepart{three} $6$ \nodepart{four} $8$}
      child {node {$1$\nodepart{two}$\times$\nodepart{three}$\times$\nodepart{four}$\times$}}
      child {node {$1$\nodepart{two}$\times$\nodepart{three}$\times$\nodepart{four}$\times$}}
      child {node {$1$\nodepart{two}$\times$\nodepart{three}$\times$\nodepart{four}$\times$}}
      child {node {$1$\nodepart{two}$\times$\nodepart{three}$\times$\nodepart{four}$\times$}}
    }
    child {node {$10$ \nodepart{two} $12$ \nodepart{three} $14$ \nodepart{four} $16$}
      child {node {$1$\nodepart{two}$\times$\nodepart{three}$\times$\nodepart{four}$\times$}}
      child {node {$1$\nodepart{two}$\times$\nodepart{three}$\times$\nodepart{four}$\times$}}
      child {node {$1$\nodepart{two}$\times$\nodepart{three}$\times$\nodepart{four}$\times$}}
      child {node {$1$\nodepart{two}$\times$\nodepart{three}$\times$\nodepart{four}$\times$}}
    }
    ;\end{tikzpicture}}
  \marginnote{First we load data into the Nested B+-trie for $R_1$.}
\end{center}

\vspace{5mm}

\begin{center}
  \marginnote{And the Nested B+-trie for $R_2$.}
  \begin{tikzpicture}
    \tikzstyle{bplus}=[rectangle split, rectangle split horizontal,rectangle split ignore empty parts,draw, fill=white]
    \tikzstyle{every node}=[bplus]
    \tikzstyle{level 1}=[sibling distance=25mm]

    \node {$4$\nodepart{two}$8$\nodepart{three}$12$\nodepart{four}$16$} [->]
    child {node {$2$\nodepart{two}$3$\nodepart{three}$\times$\nodepart{four}$\times$}}
    child {node {$2$\nodepart{two}$3$\nodepart{three}$\times$\nodepart{four}$\times$}}
    child {node {$2$\nodepart{two}$3$\nodepart{three}$\times$\nodepart{four}$\times$}}
    child {node {$2$\nodepart{two}$3$\nodepart{three}$\times$\nodepart{four}$\times$}}
    ;\end{tikzpicture}
\end{center}

\vspace{5mm}

\begin{center}
  \marginnote{And for $R_3$.}
  \begin{tikzpicture}
    \tikzstyle{bplus}=[rectangle split, rectangle split horizontal,rectangle split ignore empty parts,draw, fill=white]
    \tikzstyle{every node}=[bplus]
    \tikzstyle{level 1}=[sibling distance=25mm]

    \node {$1$} [->]
    child {node {$2$\nodepart{two}$\times$\nodepart{three}$\times$\nodepart{four}$\times$}}
    ;\end{tikzpicture}
\end{center}

\vspace{5mm}

\marginnote{The initial result of the join consists of $(4,1,2$, $(8,1,2)$, $(12,1,2)$, $(16,1,2)$, which will fit into a single leaf node in the Fractal Tree Index.}
\begin{center}
  \begin{tikzpicture}
    \tikzstyle{bplus}=[rectangle split, rectangle split horizontal,rectangle split ignore empty parts,draw, fill=white]
    \tikzstyle{every node}=[bplus]
    \tikzstyle{level 1}=[sibling distance=50mm]

    \node {$4,1,2$\nodepart{two}$8,1,2$\nodepart{three}$12,1,2$\nodepart{four}$16,1,2$} [->]
    ;\end{tikzpicture}
\end{center}

\vspace{5mm}

\begin{center}
  \marginnote{Suppose $+R_3(1,3)$.}
  \begin{tikzpicture}
    \tikzstyle{bplus}=[rectangle split, rectangle split horizontal,rectangle split ignore empty parts,draw, fill=white]
    \tikzstyle{every node}=[bplus]
    \tikzstyle{level 1}=[sibling distance=25mm]

    \node {$1$} [->]
    child {node {$2$\nodepart{two}$3$\nodepart{three}$\times$\nodepart{four}$\times$}}
    ;\end{tikzpicture}
\end{center}

\vspace{5mm}

\marginnote{Calculating the differential join, we find we must insert $(4,1,3)$, $(8,1,3)$, $(12,1,3)$, $(16,1,3)$. We start with $(4,1,3)$.}
\begin{center}
  \begin{tikzpicture}
    \tikzstyle{bplus}=[rectangle split, rectangle split horizontal,rectangle split ignore empty parts,draw, fill=white]
    \tikzstyle{every node}=[bplus]
    \tikzstyle{level 1}=[sibling distance=50mm]

    \node[rectangle split parts=5]{$4,1,2$\nodepart{two}$4,1,3$\nodepart{three}$8,1,2$\nodepart{four}$12,1,2$\nodepart{five}\textcolor{red}{$\mathbf{16,1,2}$}} [->]
    ;\end{tikzpicture}
\end{center}

\vspace{5mm}

\marginnote{The leaf was overfull, so we split it.}
\begin{center}
  \begin{tikzpicture}
    \tikzstyle{bplus}=[rectangle split, rectangle split horizontal,rectangle split ignore empty parts,draw, fill=white]
    \tikzstyle{every node}=[bplus]
    \tikzstyle{level 1}=[sibling distance=50mm]

    \node{$8,1,2$} [->]
    child {node {$4,1,2$ \nodepart{two} $4,1,3$ \nodepart{three} $8,1,2$ \nodepart{four} $\times$} edge from parent[dashed] node[solid,rectangle,rounded corners=7pt,fill=white,draw] {$\varnothing$}}
    child {node {$12,1,2$ \nodepart{two} $16,1,2$ \nodepart{three} $\times$ \nodepart{four} $\times$} edge from parent[dashed] node[solid,rectangle,rounded corners=7pt,fill=white,draw] {$\varnothing$}}
    ;\end{tikzpicture}
\end{center}

\vspace{5mm}

\marginnote{Inserting $(8,1,3)$ now just involves adding it to the transaction buffer.}
\begin{center}
  \begin{tikzpicture}
    \tikzstyle{bplus}=[rectangle split, rectangle split horizontal,rectangle split ignore empty parts,draw, fill=white]
    \tikzstyle{every node}=[bplus]
    \tikzstyle{level 1}=[sibling distance=50mm]

    \node{$8,1,2$} [->]
    child {node {$4,1,2$ \nodepart{two} $4,1,3$ \nodepart{three} $8,1,2$ \nodepart{four} $\times$} edge from parent[dashed] node[solid,rectangle,rounded corners=7pt,fill=white,draw] {$\varnothing$}}
    child {node {$12,1,2$ \nodepart{two} $16,1,2$ \nodepart{three} $\times$ \nodepart{four} $\times$} edge from parent[dashed] node[solid,rectangle,rounded corners=7pt,fill=white,draw] {$+(8,1,3)$}}
    ;\end{tikzpicture}
\end{center}

\vspace{5mm}

\marginnote{Next we insert $(12,1,3)$.}
\begin{center}
  \begin{tikzpicture}
    \tikzstyle{bplus}=[rectangle split, rectangle split horizontal,rectangle split ignore empty parts,draw, fill=white]
    \tikzstyle{every node}=[bplus]
    \tikzstyle{level 1}=[sibling distance=50mm]

    \node{$8,1,2$} [->]
    child {node {$4,1,2$ \nodepart{two} $4,1,3$ \nodepart{three} $8,1,2$ \nodepart{four} $\times$} edge from parent[dashed] node[solid,rectangle,rounded corners=7pt,fill=white,draw] {$\varnothing$}}
    child {node {$12,1,2$ \nodepart{two} $16,1,2$ \nodepart{three} $\times$ \nodepart{four} $\times$} edge from parent[dashed] node[solid,rectangle,rectangle split,rectangle split parts=2,rounded corners=7pt,fill=white,draw] {$+(8,1,3)$\nodepart{two}\textcolor{red}{$\mathbf{+(12,1,3)}$}}}
    ;\end{tikzpicture}
\end{center}

\vspace{5mm}

\marginnote{The transaction buffer is now too full, so it is flushed.}
\begin{center}
  \begin{tikzpicture}
    \tikzstyle{bplus}=[rectangle split, rectangle split horizontal,rectangle split ignore empty parts,draw, fill=white]
    \tikzstyle{every node}=[bplus]
    \tikzstyle{level 1}=[sibling distance=50mm]

    \node{$8,1,2$} [->]
    child {node {$4,1,2$ \nodepart{two} $4,1,3$ \nodepart{three} $8,1,2$ \nodepart{four} $\times$} edge from parent[dashed] node[solid,rectangle,rounded corners=7pt,fill=white,draw] {$\varnothing$}}
    child {node {$8,1,3$\nodepart{two}$12,1,2$\nodepart{three}$12,1,3$\nodepart{four}$16,1,2$} edge from parent[dashed] node[solid,rectangle,rounded corners=7pt,fill=white,draw] {$\varnothing$}}
    ;\end{tikzpicture}
\end{center}

\vspace{5mm}

\marginnote{Finally we insert $(16,1,3)$ which once again sits in the transaction buffer, avoiding the split of the (full) node it will eventually go to.}
\begin{center}
  \begin{tikzpicture}
    \tikzstyle{bplus}=[rectangle split, rectangle split horizontal,rectangle split ignore empty parts,draw, fill=white]
    \tikzstyle{every node}=[bplus]
    \tikzstyle{level 1}=[sibling distance=50mm]

    \node{$8,1,2$} [->]
    child {node {$4,1,2$ \nodepart{two} $4,1,3$ \nodepart{three} $8,1,2$ \nodepart{four} $\times$} edge from parent[dashed] node[solid,rectangle,rounded corners=7pt,fill=white,draw] {$\varnothing$}}
    child {node {$8,1,3$\nodepart{two}$12,1,2$\nodepart{three}$12,1,3$\nodepart{four}$16,1,2$} edge from parent[dashed] node[solid,rectangle,rounded corners=7pt,fill=white,draw] {$+(16,1,3)$}}
    ;\end{tikzpicture}
\end{center}

\vspace{5mm}

\begin{center}
  \marginnote{Now suppose we do $-R_3(1,2)$.}
  \begin{tikzpicture}
    \tikzstyle{bplus}=[rectangle split, rectangle split horizontal,rectangle split ignore empty parts,draw, fill=white]
    \tikzstyle{every node}=[bplus]
    \tikzstyle{level 1}=[sibling distance=25mm]

    \node {$1$} [->]
    child {node {$3$\nodepart{two}$\times$\nodepart{three}$\times$\nodepart{four}$\times$}}
    ;\end{tikzpicture}
\end{center}

\vspace{5mm}

\marginnote{As a result we must remove $(4,1,2)$,$(8,1,2)$,$(12,1,2)$,$(16,1,2)$. We start with $(4,1,2)$.}
\begin{center}
  \begin{tikzpicture}
    \tikzstyle{bplus}=[rectangle split, rectangle split horizontal,rectangle split ignore empty parts,draw, fill=white]
    \tikzstyle{every node}=[bplus]
    \tikzstyle{level 1}=[sibling distance=50mm]

    \node{$8,1,2$} [->]
    child {node {$4,1,2$ \nodepart{two} $4,1,3$ \nodepart{three} $8,1,2$ \nodepart{four} $\times$} edge from parent[dashed] node[solid,rectangle,rounded corners=7pt,fill=white,draw] {$-(4,1,2)$}}
    child {node {$8,1,3$\nodepart{two}$12,1,2$\nodepart{three}$12,1,3$\nodepart{four}$16,1,2$} edge from parent[dashed] node[solid,rectangle,rounded corners=7pt,fill=white,draw] {$+(16,1,3)$}}
    ;\end{tikzpicture}
\end{center}

\vspace{5mm}

\marginnote{Then $(8,1,2)$.}
\begin{center}
  \begin{tikzpicture}
    \tikzstyle{bplus}=[rectangle split, rectangle split horizontal,rectangle split ignore empty parts,draw, fill=white]
    \tikzstyle{every node}=[bplus]
    \tikzstyle{level 1}=[sibling distance=55mm]

    \node{$8,1,2$} [->]
    child {node {$4,1,2$ \nodepart{two} $4,1,3$ \nodepart{three} $8,1,2$ \nodepart{four} $\times$} edge from parent[dashed] node[solid,rectangle,rectangle split,rectangle split parts=2,rounded corners=7pt,fill=white,draw] {$-(4,1,2)$\nodepart{two}\textcolor{red}{$\mathbf{-(8,1,2)}$}}}
    child {node {$8,1,3$\nodepart{two}$12,1,2$\nodepart{three}$12,1,3$\nodepart{four}$16,1,2$} edge from parent[dashed] node[solid,rectangle,rounded corners=7pt,fill=white,draw] {$+(16,1,3)$}}
    ;\end{tikzpicture}
\end{center}

\vspace{5mm}

\marginnote{We flush the overfull transaction buffer. (Note, we do not merge the node with its neighbour, as they are not \textit{both} under-occupied.)}
\begin{center}
  \begin{tikzpicture}
    \tikzstyle{bplus}=[rectangle split, rectangle split horizontal,rectangle split ignore empty parts,draw, fill=white]
    \tikzstyle{every node}=[bplus]
    \tikzstyle{level 1}=[sibling distance=55mm]

    \node{$8,1,2$} [->]
    child {node {$4,1,3$ \nodepart{two} $\times$ \nodepart{three} $\times$ \nodepart{four} $\times$} edge from parent[dashed] node[solid,rectangle,rounded corners=7pt,fill=white,draw] {$\varnothing$}}
    child {node {$8,1,3$\nodepart{two}$12,1,2$\nodepart{three}$12,1,3$\nodepart{four}$16,1,2$} edge from parent[dashed] node[solid,rectangle,rounded corners=7pt,fill=white,draw] {$+(16,1,3)$}}
    ;\end{tikzpicture}
\end{center}

\vspace{5mm}

\marginnote{Node $(12,1,2)$.}
\begin{center}
  \begin{tikzpicture}
    \tikzstyle{bplus}=[rectangle split, rectangle split horizontal,rectangle split ignore empty parts,draw, fill=white]
    \tikzstyle{every node}=[bplus]
    \tikzstyle{level 1}=[sibling distance=55mm]

    \node{$8,1,2$} [->]
    child {node {$4,1,3$ \nodepart{two} $\times$ \nodepart{three} $\times$ \nodepart{four} $\times$} edge from parent[dashed] node[solid,rectangle,rounded corners=7pt,fill=white,draw] {$\varnothing$}}
    child {node {$8,1,3$\nodepart{two}$12,1,2$\nodepart{three}$12,1,3$\nodepart{four}$16,1,2$} edge from parent[dashed] node[solid,rectangle,rectangle split,rectangle split parts=2,rounded corners=7pt,fill=white,draw] {$-(12,1,2)$\nodepart{two}\textcolor{red}{$\mathbf{+(16,1,3)}$}}}
    ;\end{tikzpicture}
\end{center}

\vspace{5mm}

\marginnote{Which causes a flush.}
\begin{center}
  \begin{tikzpicture}
    \tikzstyle{bplus}=[rectangle split, rectangle split horizontal,rectangle split ignore empty parts,draw, fill=white]
    \tikzstyle{every node}=[bplus]
    \tikzstyle{level 1}=[sibling distance=55mm]

    \node{$8,1,2$} [->]
    child {node {$4,1,3$ \nodepart{two} $\times$ \nodepart{three} $\times$ \nodepart{four} $\times$} edge from parent[dashed] node[solid,rectangle,rounded corners=7pt,fill=white,draw] {$\varnothing$}}
    child {node {$8,1,3$\nodepart{two}$12,1,3$\nodepart{three}$16,1,2$\nodepart{four}$16,1,3$} edge from parent[dashed] node[solid,rectangle,rounded corners=7pt,fill=white,draw] {$\varnothing$}}
    ;\end{tikzpicture}
\end{center}

\vspace{5mm}

\marginnote{Finally $(16,1,2)$.}
\begin{center}
  \begin{tikzpicture}
    \tikzstyle{bplus}=[rectangle split, rectangle split horizontal,rectangle split ignore empty parts,draw, fill=white]
    \tikzstyle{every node}=[bplus]
    \tikzstyle{level 1}=[sibling distance=55mm]

    \node{$8,1,2$} [->]
    child {node {$4,1,3$ \nodepart{two} $\times$ \nodepart{three} $\times$ \nodepart{four} $\times$} edge from parent[dashed] node[solid,rectangle,rounded corners=7pt,fill=white,draw] {$\varnothing$}}
    child {node {$8,1,3$\nodepart{two}$12,1,3$\nodepart{three}$16,1,2$\nodepart{four}$16,1,3$} edge from parent[dashed] node[solid,rectangle,rounded corners=7pt,fill=white,draw] {$-(16,1,2)$}}
    ;\end{tikzpicture}
\end{center}

Likewise, preserving a count query:

\begin{align*}
  &           && \phantom{+4~}\text{ Initially } & C & = 4 \\
  & +R_3(1,3) && +4\text{ records }\implies      & C & = 8 \\
  & -R_3(1,2) && -4\text{ records }\implies      & C & = 4
\end{align*}

Now, we turn our attention to performance analysis. We will use the same definitions as in Part (a.iv), but generalised so that now $P_i = \#\text{Pages in }R_i$. W.l.o.g. $P_1\leq P_2\leq\cdots\leq P_k$.\\[1em]

As before, when maintaining an equijoin query, Na\"iveDB performs a merge over all tables, which in the worst-case will involve scanning them all:
\begin{align*}
  &\textit{Equijoin} && O(m(P_V + kP_k)) &&\\
  &\textit{Count}    && O(mkP_k) &&
  \intertext{On the other hand, IncDB will scan all but one of the tables, which in the worst-case will involve $kP_k-P_1$ IO's. The update cost remains the same, however.}
  &\textit{Equijoin} && O\left(m(kP_k-P_1) + \frac{T\log_B(P_V)}{\sqrt{B}}\right) &&\\
  &\textit{Count}    && O(m(kP_k-P_1)) &&
\end{align*}
